import * as github from '@actions/github';
import * as core from '@actions/core';
import { Command } from './types';

// GitHub's maximum comment body length
const GITHUB_MAX_COMMENT_LENGTH = 65536;
// Safety margin to account for headers, footers, and formatting
const SAFETY_MARGIN = 1000;
const MAX_CONTENT_LENGTH = GITHUB_MAX_COMMENT_LENGTH - SAFETY_MARGIN;

export class GitHubService {
  private octokit: ReturnType<typeof github.getOctokit>;
  private context: typeof github.context;

  constructor(token: string) {
    this.octokit = github.getOctokit(token);
    this.context = github.context;
  }

  /**
   * Build the markdown for a single image section
   * @param imageTypePrefix - The prefix for the image type (e.g., "Wireframe" or "Concept")
   * @param imageNumber - The display number for the image (1-indexed)
   * @param imageUrl - The URL of the image
   * @returns The markdown string for the image section
   */
  private buildImageSection(imageTypePrefix: string, imageNumber: number, imageUrl: string): string {
    return `### ${imageTypePrefix} ${imageNumber}\n![${imageTypePrefix} ${imageNumber}](${imageUrl})\n\n`;
  }

  /**
   * Split image URLs into chunks that fit within GitHub's comment length limit
   * @param imageUrls - Array of image URLs to be posted
   * @param imageType - The full image type string (e.g., "Wireframe Images" or "Concept Images")
   * @param totalImages - Total number of images (used for header generation)
   * @returns Array of chunks, where each chunk contains indices into the imageUrls array.
   *          Returns indices instead of URLs to avoid O(nÂ²) complexity when building comments.
   */
  private splitImageUrlsIntoChunks(imageUrls: string[], imageType: string, totalImages: number): number[][] {
    const chunks: number[][] = [];
    let currentChunk: number[] = [];
    let currentLength = 0;

    // Calculate header and footer length for each part
    const header = `## ${imageType}\n\nGenerated ${totalImages} ${imageType.toLowerCase()} based on the requirements:\n\n`;
    const footer = `---\n*Generated by @gen-visual*`;
    const fixedLength = header.length + footer.length;
    const imageTypePrefix = imageType.split(' ')[0] || imageType;

    for (let i = 0; i < imageUrls.length; i++) {
      const url = imageUrls[i];
      // Calculate the length of this image section
      const imageSection = this.buildImageSection(imageTypePrefix, i + 1, url);
      const imageSectionLength = imageSection.length;

      // Check if adding this image would exceed the limit
      if (currentLength + imageSectionLength + fixedLength > MAX_CONTENT_LENGTH && currentChunk.length > 0) {
        // Start a new chunk
        chunks.push(currentChunk);
        currentChunk = [];
        currentLength = 0;
      }

      currentChunk.push(i);
      currentLength += imageSectionLength;
    }

    // Add the last chunk if it has images
    if (currentChunk.length > 0) {
      chunks.push(currentChunk);
    }

    return chunks;
  }

  async postComment(issueNumber: number, imageUrls: string[], command: Command): Promise<void> {
    const imageType = command.type === 'concept' ? 'Concept Images' : 'Wireframe Images';
    const totalImages = imageUrls.length;
    const imageTypePrefix = imageType.split(' ')[0] || imageType;
    
    // Split images into chunks if needed
    const chunks = this.splitImageUrlsIntoChunks(imageUrls, imageType, totalImages);
    
    try {
      // Post each chunk as a separate comment
      for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
        const chunk = chunks[chunkIndex];
        const partInfo = chunks.length > 1 ? ` (Part ${chunkIndex + 1}/${chunks.length})` : '';
        
        // Build comment with images
        let commentBody = `## ${imageType}${partInfo}\n\n`;
        commentBody += `Generated ${totalImages} ${imageType.toLowerCase()} based on the requirements:\n\n`;
        
        chunk.forEach((imageIndex) => {
          const url = imageUrls[imageIndex];
          commentBody += this.buildImageSection(imageTypePrefix, imageIndex + 1, url);
        });
        
        commentBody += `---\n*Generated by @gen-visual*`;

        await this.octokit.rest.issues.createComment({
          owner: this.context.repo.owner,
          repo: this.context.repo.repo,
          issue_number: issueNumber,
          body: commentBody
        });
      }
      
      core.info(`Posted ${chunks.length} comment(s) with ${imageUrls.length} images to issue #${issueNumber}`);
    } catch (error) {
      core.error(`Failed to post comment: ${error}`);
      throw error;
    }
  }

  getIssueContext() {
    const payload = this.context.payload;
    
    return {
      issueNumber: payload.issue?.number || 0,
      issueBody: payload.issue?.body || '',
      commentBody: payload.comment?.body || payload.issue?.body || '',
      repository: `${this.context.repo.owner}/${this.context.repo.repo}`
    };
  }
}
