import * as github from '@actions/github';
import * as core from '@actions/core';
import { Command } from './types';

export class GitHubService {
  private octokit: ReturnType<typeof github.getOctokit>;
  private context: typeof github.context;

  constructor(token: string) {
    this.octokit = github.getOctokit(token);
    this.context = github.context;
  }

  async postComment(issueNumber: number, imageUrls: string[], command: Command): Promise<void> {
    const imageType = command.type === 'concept' ? 'Concept Images' : 'Wireframe Images';
    const MAX_COMMENT_SIZE = 60000; // GitHub limit is 65536, leave some buffer for safety
    
    try {
      const totalImages = imageUrls.length;
      let commentNumber = 1;
      let imagesInCurrentComment: number[] = [];
      let currentCommentBody = '';
      
      // Helper function to calculate the size of a comment body
      const getCommentSize = (body: string): number => {
        return body.length;
      };
      
      // Helper function to build image markdown
      const buildImageMarkdown = (index: number, url: string): string => {
        return `### ${imageType.split(' ')[0]} ${index + 1}\n![${imageType} ${index + 1}](${url})\n\n`;
      };
      
      // Process each image
      for (let i = 0; i < imageUrls.length; i++) {
        const imageMarkdown = buildImageMarkdown(i + 1, imageUrls[i]);
        const newCommentBody = currentCommentBody + imageMarkdown;
        const newCommentSize = getCommentSize(newCommentBody);
        
        // If adding this image would exceed the limit, post current comment and start new one
        if (newCommentSize > MAX_COMMENT_SIZE && imagesInCurrentComment.length > 0) {
          // Add footer to current comment
          const commentToPost = currentCommentBody.trim() + (commentNumber === 1 ? `\n\n---\n*Generated by @gen-visual*` : '');
          
          await this.octokit.rest.issues.createComment({
            owner: this.context.repo.owner,
            repo: this.context.repo.repo,
            issue_number: issueNumber,
            body: commentToPost
          });
          
          const imageRange = imagesInCurrentComment.length === 1 
            ? `image ${imagesInCurrentComment[0]}`
            : `images ${imagesInCurrentComment[0]}-${imagesInCurrentComment[imagesInCurrentComment.length - 1]}`;
          core.info(`Posted comment ${commentNumber} with ${imageRange} to issue #${issueNumber}`);
          
          // Start new comment
          commentNumber++;
          currentCommentBody = '';
          imagesInCurrentComment = [];
        }
        
        // If this is the first image in a new comment, add header
        if (imagesInCurrentComment.length === 0) {
          if (commentNumber === 1) {
            currentCommentBody += `## ${imageType}\n\n`;
            currentCommentBody += `Generated ${totalImages} ${imageType.toLowerCase()} based on the requirements:\n\n`;
          } else {
            currentCommentBody += `## ${imageType} (continued)\n\n`;
          }
        }
        
        // Add image to current comment
        currentCommentBody += imageMarkdown;
        imagesInCurrentComment.push(i + 1);
      }
      
      // Post the last comment with footer
      if (currentCommentBody.length > 0) {
        const footer = commentNumber === 1 
          ? `---\n*Generated by @gen-visual*`
          : `\n\n---\n*Generated by @gen-visual*`;
        const commentToPost = currentCommentBody.trim() + footer;
        
        await this.octokit.rest.issues.createComment({
          owner: this.context.repo.owner,
          repo: this.context.repo.repo,
          issue_number: issueNumber,
          body: commentToPost
        });
        
        const imageRange = imagesInCurrentComment.length === 1 
          ? `image ${imagesInCurrentComment[0]}`
          : `images ${imagesInCurrentComment[0]}-${imagesInCurrentComment[imagesInCurrentComment.length - 1]}`;
        core.info(`Posted comment ${commentNumber} with ${imageRange} to issue #${issueNumber}`);
      }
      
      if (commentNumber > 1) {
        core.info(`Posted ${commentNumber} comments in total with ${totalImages} images to issue #${issueNumber}`);
      } else {
        core.info(`Posted comment with ${totalImages} images to issue #${issueNumber}`);
      }
    } catch (error) {
      core.error(`Failed to post comment: ${error}`);
      throw error;
    }
  }

  getIssueContext() {
    const payload = this.context.payload;
    
    return {
      issueNumber: payload.issue?.number || 0,
      issueBody: payload.issue?.body || '',
      commentBody: payload.comment?.body || payload.issue?.body || '',
      repository: `${this.context.repo.owner}/${this.context.repo.repo}`
    };
  }
}
