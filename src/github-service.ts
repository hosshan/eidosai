import * as github from '@actions/github';
import * as core from '@actions/core';
import { Command, ImageData } from './types';

export class GitHubService {
  private octokit: ReturnType<typeof github.getOctokit>;
  private context: typeof github.context;

  constructor(token: string) {
    this.octokit = github.getOctokit(token);
    this.context = github.context;
  }

  async createProgressComment(issueNumber: number, command: Command): Promise<number> {
    const imageType = command.type === 'concept' 
      ? 'Concept Images' 
      : command.type === 'custom' 
      ? 'Custom Images' 
      : command.type === 'modify'
      ? 'Modified Images'
      : 'Wireframe Images';
    const initialBody = `## ${imageType}\n\n⏳ 画像を生成中...\n\n*Generated by @gen-visual*`;
    
    try {
      const response = await this.octokit.rest.issues.createComment({
        owner: this.context.repo.owner,
        repo: this.context.repo.repo,
        issue_number: issueNumber,
        body: initialBody
      });
      
      const commentId = response.data.id;
      core.info(`Created progress comment #${commentId} for issue #${issueNumber}`);
      return commentId;
    } catch (error) {
      core.error(`Failed to create progress comment: ${error}`);
      throw error;
    }
  }

  async updateProgressComment(commentId: number, issueNumber: number, progress: string): Promise<void> {
    try {
      await this.octokit.rest.issues.updateComment({
        owner: this.context.repo.owner,
        repo: this.context.repo.repo,
        comment_id: commentId,
        body: progress
      });
      core.info(`Updated progress comment #${commentId}`);
    } catch (error) {
      core.error(`Failed to update progress comment: ${error}`);
      throw error;
    }
  }

  async postComment(issueNumber: number, imageUrls: string[], command: Command, progressCommentId: number): Promise<void> {
    const imageType = command.type === 'concept' 
      ? 'Concept Images' 
      : command.type === 'custom' 
      ? 'Custom Images' 
      : command.type === 'modify'
      ? 'Modified Images'
      : 'Wireframe Images';
    const MAX_COMMENT_SIZE = 65536; // GitHub limit
    
    try {
      const totalImages = imageUrls.length;
      core.info(`Preparing comment with ${totalImages} images...`);
      
      // URLの長さを確認
      const urlLengths = imageUrls.map(url => url.length);
      const totalUrlLength = urlLengths.reduce((sum, len) => sum + len, 0);
      const avgUrlLength = Math.round(totalUrlLength / imageUrls.length);
      core.info(`URL length analysis:`);
      core.info(`  Total URLs length: ${totalUrlLength} chars`);
      core.info(`  Average URL length: ${avgUrlLength} chars`);
      urlLengths.forEach((len, i) => {
        core.info(`  URL ${i + 1}: ${len} chars`);
      });
      
      // コメント本文を構築
      let commentBody = `## ${imageType}\n\n`;
      if (command.type === 'custom' && command.customPrompt) {
        commentBody += `Generated ${totalImages} ${imageType.toLowerCase()} based on the requirements and custom instruction: "${command.customPrompt}"\n\n`;
      } else {
        commentBody += `Generated ${totalImages} ${imageType.toLowerCase()} based on the requirements:\n\n`;
      }
      
      // 画像を追加（![alt](url) 形式なので、URLの長さだけが問題）
      for (let i = 0; i < imageUrls.length; i++) {
        commentBody += `### ${imageType.split(' ')[0]} ${i + 1}/${totalImages}\n`;
        commentBody += `![${imageType} ${i + 1}](${imageUrls[i]})\n\n`;
      }
      
      commentBody += `---\n*Generated by @gen-visual*`;
      
      // サイズチェック
      const commentSize = commentBody.length;
      core.info(`Comment body size: ${commentSize} chars (limit: ${MAX_COMMENT_SIZE} chars)`);
      core.info(`  Header/Footer size: ~${commentBody.length - totalUrlLength} chars`);
      core.info(`  URLs total size: ${totalUrlLength} chars`);
      
      if (commentSize > MAX_COMMENT_SIZE) {
        const excess = commentSize - MAX_COMMENT_SIZE;
        core.error(`Comment size (${commentSize} chars) exceeds GitHub limit (${MAX_COMMENT_SIZE} chars) by ${excess} chars.`);
        core.error(`This is likely due to very long signed URLs. Consider reducing the number of images or using shorter URLs.`);
        throw new Error(`Comment body is too long (${commentSize} chars, limit: ${MAX_COMMENT_SIZE} chars). Cannot post comment.`);
      }
      
      // 進捗コメントを更新
      await this.updateProgressComment(progressCommentId, issueNumber, commentBody.trim());
      core.info(`Updated progress comment with ${totalImages} images to issue #${issueNumber}`);
    } catch (error) {
      core.error(`Failed to post comment: ${error}`);
      throw error;
    }
  }

  getIssueContext() {
    const payload = this.context.payload;
    const commentId = payload.comment?.id;
    const isFromComment = !!payload.comment;
    
    return {
      issueNumber: payload.issue?.number || 0,
      issueBody: payload.issue?.body || '',
      commentBody: payload.comment?.body || payload.issue?.body || '',
      repository: `${this.context.repo.owner}/${this.context.repo.repo}`,
      commentId: commentId,
      isFromComment: isFromComment
    };
  }

  async addReactionToComment(commentId: number): Promise<void> {
    try {
      await this.octokit.rest.reactions.createForIssueComment({
        owner: this.context.repo.owner,
        repo: this.context.repo.repo,
        comment_id: commentId,
        content: 'eyes'
      });
      core.info(`Added :eye: reaction to comment #${commentId}`);
    } catch (error) {
      core.warning(`Failed to add reaction to comment: ${error}`);
      // Don't throw - reaction failure shouldn't stop the process
    }
  }

  async addReactionToIssue(issueNumber: number): Promise<void> {
    try {
      await this.octokit.rest.reactions.createForIssue({
        owner: this.context.repo.owner,
        repo: this.context.repo.repo,
        issue_number: issueNumber,
        content: 'eyes'
      });
      core.info(`Added :eye: reaction to issue #${issueNumber}`);
    } catch (error) {
      core.warning(`Failed to add reaction to issue: ${error}`);
      // Don't throw - reaction failure shouldn't stop the process
    }
  }

  /**
   * Extract image URLs from comment body
   * Supports Markdown format: ![alt](url)
   */
  extractImageUrls(commentBody: string): string[] {
    const imageUrls: string[] = [];
    
    // Match Markdown image format: ![alt](url)
    const markdownImageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    let match;
    
    while ((match = markdownImageRegex.exec(commentBody)) !== null) {
      const url = match[2].trim();
      if (url) {
        imageUrls.push(url);
      }
    }
    
    core.info(`Extracted ${imageUrls.length} image URL(s) from comment`);
    return imageUrls;
  }

  /**
   * Download image from URL and convert to base64
   */
  async downloadImageAsBase64(imageUrl: string): Promise<ImageData | null> {
    try {
      core.info(`Downloading image from: ${imageUrl}`);
      
      const response = await fetch(imageUrl);
      if (!response.ok) {
        throw new Error(`Failed to download image: ${response.status} ${response.statusText}`);
      }
      
      const arrayBuffer = await response.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      const base64Data = buffer.toString('base64');
      
      // Determine MIME type from response headers or URL
      let mimeType = response.headers.get('content-type') || 'image/png';
      if (!mimeType.startsWith('image/')) {
        // Fallback: try to determine from URL extension
        const urlLower = imageUrl.toLowerCase();
        if (urlLower.includes('.png')) {
          mimeType = 'image/png';
        } else if (urlLower.includes('.jpg') || urlLower.includes('.jpeg')) {
          mimeType = 'image/jpeg';
        } else if (urlLower.includes('.gif')) {
          mimeType = 'image/gif';
        } else if (urlLower.includes('.webp')) {
          mimeType = 'image/webp';
        } else {
          mimeType = 'image/png'; // Default fallback
        }
      }
      
      core.info(`Successfully downloaded image (${mimeType}, ${buffer.length} bytes)`);
      
      return {
        mimeType,
        base64Data
      };
    } catch (error) {
      core.warning(`Failed to download image from ${imageUrl}: ${error}`);
      return null;
    }
  }

  /**
   * Extract and download images from comment body
   */
  async extractAndDownloadImages(commentBody: string): Promise<ImageData[]> {
    const imageUrls = this.extractImageUrls(commentBody);
    const images: ImageData[] = [];
    
    for (const url of imageUrls) {
      const imageData = await this.downloadImageAsBase64(url);
      if (imageData) {
        images.push(imageData);
      }
    }
    
    core.info(`Successfully extracted ${images.length} image(s) from comment`);
    return images;
  }
}
