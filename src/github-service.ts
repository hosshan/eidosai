import * as github from '@actions/github';
import * as core from '@actions/core';
import { Command } from './types';

// GitHub's maximum comment body length
const GITHUB_MAX_COMMENT_LENGTH = 65536;
// Safety margin to account for headers, footers, and formatting
const SAFETY_MARGIN = 1000;
const MAX_CONTENT_LENGTH = GITHUB_MAX_COMMENT_LENGTH - SAFETY_MARGIN;

export class GitHubService {
  private octokit: ReturnType<typeof github.getOctokit>;
  private context: typeof github.context;

  constructor(token: string) {
    this.octokit = github.getOctokit(token);
    this.context = github.context;
  }

  /**
   * Split image URLs into chunks that fit within GitHub's comment length limit
   */
  private splitImageUrlsIntoChunks(imageUrls: string[], imageType: string, totalImages: number): string[][] {
    const chunks: string[][] = [];
    let currentChunk: string[] = [];
    let currentLength = 0;

    // Calculate header and footer length for each part
    const header = `## ${imageType}\n\nGenerated ${totalImages} ${imageType.toLowerCase()} based on the requirements:\n\n`;
    const footer = `---\n*Generated by @gen-visual*`;
    const fixedLength = header.length + footer.length;

    for (let i = 0; i < imageUrls.length; i++) {
      const url = imageUrls[i];
      // Calculate the length of this image section
      const imageSection = `### ${imageType.split(' ')[0]} ${i + 1}\n![${imageType} ${i + 1}](${url})\n\n`;
      const imageSectionLength = imageSection.length;

      // Check if adding this image would exceed the limit
      if (currentLength + imageSectionLength + fixedLength > MAX_CONTENT_LENGTH && currentChunk.length > 0) {
        // Start a new chunk
        chunks.push(currentChunk);
        currentChunk = [];
        currentLength = 0;
      }

      currentChunk.push(url);
      currentLength += imageSectionLength;
    }

    // Add the last chunk if it has images
    if (currentChunk.length > 0) {
      chunks.push(currentChunk);
    }

    return chunks;
  }

  async postComment(issueNumber: number, imageUrls: string[], command: Command): Promise<void> {
    const imageType = command.type === 'concept' ? 'Concept Images' : 'Wireframe Images';
    const totalImages = imageUrls.length;
    
    // Split images into chunks if needed
    const chunks = this.splitImageUrlsIntoChunks(imageUrls, imageType, totalImages);
    
    try {
      // Post each chunk as a separate comment
      for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
        const chunk = chunks[chunkIndex];
        const partInfo = chunks.length > 1 ? ` (Part ${chunkIndex + 1}/${chunks.length})` : '';
        
        // Build comment with images
        let commentBody = `## ${imageType}${partInfo}\n\n`;
        commentBody += `Generated ${totalImages} ${imageType.toLowerCase()} based on the requirements:\n\n`;
        
        chunk.forEach((url) => {
          const originalIndex = imageUrls.indexOf(url);
          commentBody += `### ${imageType.split(' ')[0]} ${originalIndex + 1}\n`;
          commentBody += `![${imageType} ${originalIndex + 1}](${url})\n\n`;
        });
        
        commentBody += `---\n*Generated by @gen-visual*`;

        await this.octokit.rest.issues.createComment({
          owner: this.context.repo.owner,
          repo: this.context.repo.repo,
          issue_number: issueNumber,
          body: commentBody
        });
      }
      
      core.info(`Posted ${chunks.length} comment(s) with ${imageUrls.length} images to issue #${issueNumber}`);
    } catch (error) {
      core.error(`Failed to post comment: ${error}`);
      throw error;
    }
  }

  getIssueContext() {
    const payload = this.context.payload;
    
    return {
      issueNumber: payload.issue?.number || 0,
      issueBody: payload.issue?.body || '',
      commentBody: payload.comment?.body || payload.issue?.body || '',
      repository: `${this.context.repo.owner}/${this.context.repo.repo}`
    };
  }
}
